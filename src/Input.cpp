#include "Input.h"
#include "Camera.h"   // ::Camera (yaw, pitch, moveForward/Right/Up)
#include <cmath>
#include <cstdlib>
#include <iostream>

// Local clamp that doesn’t require C++17
static inline float clampf(float v, float lo, float hi) {
    return (v < lo) ? lo : (v > hi ? hi : v);
}

namespace neoquake {

void Input_Init(GLFWwindow* win, InputContext* ictx) {
    // Store pointer so callbacks can find our context
    glfwSetWindowUserPointer(win, ictx);

    // Attach our cursor callback
    glfwSetCursorPosCallback(win, Input_CursorPosCallback);

    // Cache window size
    glfwGetWindowSize(win, &ictx->winW, &ictx->winH);

    // Initialize ignoreNextCursorEvent flag
    ictx->ignoreNextCursorEvent = false;
}

void Input_OnResize(GLFWwindow* win, int width, int height) {
    auto* ictx = static_cast<InputContext*>(glfwGetWindowUserPointer(win));
    if (!ictx) return;
    ictx->winW = width;
    ictx->winH = height;
}

// Center-warp relative mouse look
void Input_CursorPosCallback(GLFWwindow* win, double xpos, double ypos) {
    auto* ictx = static_cast<InputContext*>(glfwGetWindowUserPointer(win));
    if (!ictx || !ictx->mlook.looking) return;

    // Ignore the event generated by glfwSetCursorPos
    if (ictx->ignoreNextCursorEvent) {
        ictx->ignoreNextCursorEvent = false;
        return;
    }

    double centerX = ictx->winW * 0.5;
    double centerY = ictx->winH * 0.5;

    float dx = float(xpos - centerX);
    float dy = float(centerY - ypos); // invert Y (up = look up)

    // Warp cursor back to center so deltas remain stable
    ictx->ignoreNextCursorEvent = true;
    glfwSetCursorPos(win, centerX, centerY);

    const float MAX_D = 2000.0f;
    if (std::fabs(dx) < 100000.f && std::fabs(dy) < 100000.f) {
        dx = clampf(dx, -MAX_D, MAX_D);
        dy = clampf(dy, -MAX_D, MAX_D);
        ictx->mlook.accumDx += dx;
        ictx->mlook.accumDy += dy;
    }
}

void Input_BeginLook(GLFWwindow* win, InputContext* ictx) {
    if (!ictx) return;
    ictx->mlook.looking  = true;
    ictx->mlook.accumDx  = 0.0f;
    ictx->mlook.accumDy  = 0.0f;

    // Disable the cursor so it can move freely; enable raw motion if available.
    glfwSetInputMode(win, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
    ictx->rawEnabled = false;
    if (glfwRawMouseMotionSupported()) {
        glfwSetInputMode(win, GLFW_RAW_MOUSE_MOTION, GLFW_TRUE);
        ictx->rawEnabled = true;
    }

    // Center cursor immediately
    double centerX = ictx->winW * 0.5;
    double centerY = ictx->winH * 0.5;
    ictx->ignoreNextCursorEvent = true;
    glfwSetCursorPos(win, centerX, centerY);
}

void Input_EndLook(GLFWwindow* win, InputContext* ictx) {
    if (!ictx) return;
    ictx->mlook.looking = false;

    if (ictx->rawEnabled) {
        glfwSetInputMode(win, GLFW_RAW_MOUSE_MOTION, GLFW_FALSE);
        ictx->rawEnabled = false;
    }
    glfwSetInputMode(win, GLFW_CURSOR, GLFW_CURSOR_NORMAL);

    ictx->mlook.accumDx = 0.0f;
    ictx->mlook.accumDy = 0.0f;
}

void Input_UpdateMouseLook(InputContext* ictx, ::Camera& cam, float dt) {
    if (!ictx) return;

    // ---------- Mouse deltas (only when looking) ----------
    float dx = 0.0f, dy = 0.0f;
    if (ictx->mlook.looking) {
        dx = ictx->mlook.accumDx;
        dy = ictx->mlook.accumDy;
        ictx->mlook.accumDx = 0.0f;
        ictx->mlook.accumDy = 0.0f;

        cam.yaw   += dx * ictx->cfg.sensYaw;
        cam.pitch += (ictx->cfg.invertPitch ? -dy : dy) * ictx->cfg.sensPitch;
    }

    // We'll read the currently bound context (no need to pass a window here)
    // ---------- Arrow-key look (always available) ----------
        GLFWwindow* win = glfwGetCurrentContext();
        if (win && dt > 0.0f) {
            // Base angular speeds (radians/second)
            const float yawSpeedBase   = 1.8f; // ~103°/s
            const float pitchSpeedBase = 1.5f; // ~86°/s

            // Shift = faster turning
            const bool shiftDown =
                glfwGetKey(win, GLFW_KEY_LEFT_SHIFT)  == GLFW_PRESS ||
                glfwGetKey(win, GLFW_KEY_RIGHT_SHIFT) == GLFW_PRESS;
            const float boost = shiftDown ? 1.75f : 1.0f;

            float yawVel   = 0.0f;
            float pitchVel = 0.0f;

            // NOTE: Because view uses matRotateY(-yaw), increasing yaw turns LEFT.
            if (glfwGetKey(win, GLFW_KEY_RIGHT) == GLFW_PRESS) yawVel   -= yawSpeedBase; // look right
            if (glfwGetKey(win, GLFW_KEY_LEFT)  == GLFW_PRESS) yawVel   += yawSpeedBase; // look left

            if (glfwGetKey(win, GLFW_KEY_UP)    == GLFW_PRESS) pitchVel += pitchSpeedBase; // look up
            if (glfwGetKey(win, GLFW_KEY_DOWN)  == GLFW_PRESS) pitchVel -= pitchSpeedBase; // look down

            cam.yaw   += yawVel * boost * dt;
            cam.pitch += (ictx->cfg.invertPitch ? -pitchVel : pitchVel) * boost * dt;
        }


    // ---------- Clamp pitch and wrap yaw ----------
    if (cam.pitch >  ictx->cfg.pitchLimit) cam.pitch =  ictx->cfg.pitchLimit;
    if (cam.pitch < -ictx->cfg.pitchLimit) cam.pitch = -ictx->cfg.pitchLimit;

    const float pi = 3.1415926535f, twoPi = 6.283185307f;
    if (cam.yaw >  pi) cam.yaw -= twoPi;
    if (cam.yaw < -pi) cam.yaw += twoPi;
}

// WASD movement (unchanged)
void Input_UpdateMovement(GLFWwindow* win, ::Camera& cam, float dt) {
    float speed = (glfwGetKey(win, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS) ? 400.f : 200.f;
    speed *= dt;
    if(glfwGetKey(win, GLFW_KEY_W) == GLFW_PRESS) cam.moveForward(speed);
    if(glfwGetKey(win, GLFW_KEY_S) == GLFW_PRESS) cam.moveForward(-speed);
    if(glfwGetKey(win, GLFW_KEY_D) == GLFW_PRESS) cam.moveRight(speed);
    if(glfwGetKey(win, GLFW_KEY_A) == GLFW_PRESS) cam.moveRight(-speed);
    if(glfwGetKey(win, GLFW_KEY_SPACE) == GLFW_PRESS) cam.moveUp(speed);
    if(glfwGetKey(win, GLFW_KEY_LEFT_CONTROL) == GLFW_PRESS) cam.moveUp(-speed);
}

void Input_AdjustSensitivity(InputContext* ictx, float factor) {
    if (!ictx) return;
    ictx->cfg.sensYaw   = clampf(ictx->cfg.sensYaw   * factor, 0.00005f, 0.02f);
    ictx->cfg.sensPitch = clampf(ictx->cfg.sensPitch * factor, 0.00005f, 0.02f);
}

void Input_ToggleInvertPitch(InputContext* ictx) {
    if (!ictx) return;
    ictx->cfg.invertPitch = !ictx->cfg.invertPitch;
}

} // namespace neoquake